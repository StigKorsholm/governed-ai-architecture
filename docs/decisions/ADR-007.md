# ADR-007: Define and Enforce Graph Invariants as Contracts

> **Status:** ✅ Accepted  
> **Date:** 2025-12-22  
> **Triggered By:** ADR-001, ADR-006 (consequence: "Once the graph is SoR and validation is mandatory, invariants are no longer optional")  
> **Triggers:** —

---

## Summary

* **Decision:** Define explicit graph invariants for each node type (required/forbidden relationships, cardinality rules). Enforce invariants via Cypher queries that run after each phase.
* **Chosen approach:** Invariants as Cypher queries, phase-aware enforcement, explicit severity per invariant.
* **Why:** A graph without invariants is just a flexible data store. Without enforceable rules, the graph becomes a dumping ground for "mostly correct" data.
* **Scope:** This ADR covers the invariant framework. Specific invariants are implementation details.

---

## Context

ADR-001 established that the graph is the system of record.
ADR-006 established that LLM outputs must be validated.

This forces a question: **What does it mean for the graph to be "valid"?**

Without explicit invariants:
- Any structure is technically acceptable
- Validation has nothing authoritative to check against
- "Valid" means "parseable" — useless for semantic correctness

---

## Decision

We will define and enforce **graph invariants as contracts**:

### Core invariants

| ID | Rule | Severity | After Phase |
|----|------|----------|-------------|
| V-01 | Table must BELONGS_TO exactly one Capability | FAIL | derive |
| V-02 | Capability must MAPS_TO exactly one BIAN SD | FAIL | map |
| V-03 | BoundedContext must CONTAINS at least one Capability | FAIL | design_bc |
| V-04 | No orphan Tables | FAIL | derive |
| V-05 | Migration wave must respect dependency order | STOP | migrate |
| V-06 | Microservice must IMPLEMENTS at least one BQ | WARN | design_ms |

### Cypher implementation

```cypher
// V-01: Every Table must belong to exactly one Capability
MATCH (t:Table)
WHERE NOT (t)-[:BELONGS_TO]->(:Capability)
   OR size([(t)-[:BELONGS_TO]->(:Capability) | 1]) > 1
RETURN t.name AS entity, 'V-01 violation' AS violation
```

---

## Decision Rationale

> Invariants are relationships, not rows.

Every meaningful rule in the system is about relationships between entities. Cypher can express what Neo4j built-in constraints cannot.

---

## Consequences

### Positive Consequences

- Prevents model drift and orphan artifacts
- Makes validation deterministic and auditable
- Catches structural errors early

### Negative Consequences

- Requires careful phase-aware design
- Invariant maintenance becomes product work

---

## References

- **LinkedIn Article:** [Why the Knowledge Model Must Be a Graph](https://www.linkedin.com/pulse/why-knowledge-model-must-graph-what-breaks-when-isnt-korsholm-6zzte) (2026-01-04)
- **Related ADRs:** ADR-001 (graph as SoR), ADR-006 (validation), ADR-010 (confidence)
