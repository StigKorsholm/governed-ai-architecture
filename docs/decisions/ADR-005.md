# ADR-005: Pass References Not Payloads in Workflow Orchestration

> **Status:** ✅ Accepted  
> **Date:** 2025-12-22  
> **Triggered By:** ADR-004 (consequence: "Workflow engine has payload size limits")  
> **Triggers:** —

---

## Summary

* **Decision:** Avoid large JSON payloads in workflow wiring. Store intermediate results in external stores (Neo4j, PostgreSQL, filesystem) and pass only references (run_id, phase, entity IDs) between workflow nodes.
* **Chosen approach:** Workflows pass pointers; nodes retrieve data on demand.
* **Why:** n8n (and most workflow engines) have payload size limits that collapse under real workloads. Large payloads also make debugging impossible.
* **Scope:** This ADR covers data flow patterns in workflows. Storage locations are defined in ADR-001, ADR-002, ADR-003.

---

## Context

A typical modernization run might process:
- **200+** legacy tables
- **50+** derived capabilities
- **300+** BIAN mappings
- **1000+** validation results

If this data flows through n8n workflow nodes as JSON payloads, the result is memory pressure, timeout failures, and debugging impossibility.

---

## Decision

We will pass **references, not payloads**:

Instead of:
```json
{
  "tables": [{...}, {...}, {...}]  // 200 objects
}
```

Pass:
```json
{
  "run_id": "mip-20250105-143022",
  "phase": "extract",
  "entity_type": "Table",
  "count": 200
}
```

### Storage locations

| Data Type | Storage | Reference |
|-----------|---------|-----------|
| Entities | Neo4j | `run_id` + label |
| Validation results | PostgreSQL | `run_id` + phase |
| Artifacts | Filesystem | `run_id` + path |

---

## Consequences

### Positive Consequences

- Makes n8n viable at real workload scale
- Cleaner workflow debugging
- Explicit data lifecycle management

### Negative Consequences

- More indirection (extra DB reads)
- Must design reference conventions

---

## References

- **Related ADRs:** ADR-001 (Neo4j), ADR-002 (PostgreSQL), ADR-003 (Filesystem), ADR-004 (n8n)
