# ADR-004: Orchestrate with n8n Using Modular Workflows

> **Status:** ✅ Accepted  
> **Date:** 2025-12-22  
> **Triggered By:** ADR-006, ADR-008 (consequence: "We need long-running, pausable, inspectable workflows")  
> **Triggers:** ADR-005

---

## Summary

* **Decision:** Implement each pipeline phase as a modular n8n workflow, composed by a main orchestrator (WF-MIP-Main), with support for resume/from_phase/single/incremental execution modes.
* **Chosen approach:** n8n self-hosted with modular workflow design, external state management, and explicit checkpoint support.
* **Why:** Validator-gated execution with human checkpoints requires observable, pausable, resumable orchestration that can survive failures and be debugged visually.
* **Scope:** This ADR covers orchestration strategy. Individual workflow designs are implementation details.

---

## Context

The pipeline has multiple phases that must execute in sequence:

1. Schema extraction
2. Capability derivation
3. BIAN mapping
4. Bounded context design
5. Microservice design
6. API generation
7. Migration planning

Each phase:
- May **fail validation** (requires retry or human intervention)
- May **pause at checkpoints** (requires resume capability)
- Must be **observable** (logging, status, duration)
- Must support **partial re-runs** (don't restart from zero)

---

## Decision Drivers

1. **Resumability** — Must continue from where we left off after failure
2. **Checkpoint support** — Must pause for human review and resume
3. **Observability** — Must see what's running, what failed, how long each step takes
4. **Modularity** — Must update phases independently
5. **Debuggability** — Must inspect workflow state visually

---

## Considered Options

### Option 1 — Custom Python orchestration

**Cons:** Must build all orchestration features from scratch

### Option 2 — Apache Airflow

**Cons:** Heavy infrastructure; not designed for human-in-the-loop checkpoints

### Option 3 — Temporal.io

**Cons:** Significant learning curve; requires Temporal server

### Option 4 — n8n self-hosted ✅ **Chosen**

**Pros:** Visual workflow builder, built-in pause/resume, low barrier to entry, self-hosted

---

## Decision

We will use **n8n self-hosted** with these principles:

### 1. Modular workflow architecture

```
WF-MIP-Main (orchestrator)
    ├── WF-Extract-Schema
    ├── WF-Derive-Capabilities (CP-1)
    ├── WF-Map-BIAN (CP-2)
    ├── WF-Design-BoundedContexts
    ├── WF-Design-Microservices
    ├── WF-Generate-APIs
    └── WF-Plan-Migration (CP-3)
```

### 2. Execution modes

| Mode | Description |
|------|-------------|
| `full` | Run all phases from start |
| `from_phase` | Resume from specific phase |
| `single` | Run one phase only |
| `incremental` | Process only changed inputs |

### 3. External state management

n8n is **not** the system of record. State lives in Neo4j, PostgreSQL, and filesystem.

---

## Consequences

### Positive Consequences

- Fast delivery and visible operations
- Easy to debug (inspect workflow state visually)
- Natural support for human checkpoints
- Modular — can update phases independently

### Negative Consequences

- Scaling must be designed carefully
- n8n payload limits require workaround (ADR-005)

### Triggered ADRs

| Consequence | Triggers |
|-------------|----------|
| Workflow engine has payload size limits | ADR-005 |

---

## References

- **Related ADRs:** ADR-005 (references not payloads), ADR-008 (checkpoints)
