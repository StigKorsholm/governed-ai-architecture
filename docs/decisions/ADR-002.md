# ADR-002: PostgreSQL as Audit/Governance Store

> **Status:** ✅ Accepted  
> **Date:** 2025-12-22  
> **Triggered By:** ADR-001 (consequence: "We must separate audit/governance data from knowledge model")  
> **Triggers:** —

---

## Summary

* **Decision:** Use PostgreSQL as the audit/run history and governance store, separate from the Neo4j knowledge model.
* **Chosen approach:** Store run manifests, audit trails, checkpoint approvals, overrides, translations, errors, and prompt issues in PostgreSQL with append-only patterns for audit tables.
* **Why:** Audit data has different lifecycle, query patterns, and integrity requirements than structural knowledge. Mixing them compromises both.
* **Scope:** This ADR covers the separation of audit/governance data from the knowledge model. Specific schema design is an implementation detail.

---

## Context

ADR-001 established that the graph is the system of record for **structural knowledge** — the "what is true now" about modernization artifacts.

But modernization pipelines also produce operational data:
- **Run manifests** — what ran, when, with what config
- **Audit trails** — who approved what, when
- **Validation results** — what passed, what failed, what warned
- **Checkpoint approvals** — identity, timestamp, decision
- **Overrides** — human corrections with justifications
- **Prompt issues** — tracked problems for prompt improvement
- **Error logs** — failures and recovery actions

This data is fundamentally different from structural knowledge:

| Characteristic | Knowledge Model | Audit Data |
|----------------|-----------------|------------|
| Mutability | Updated as truth evolves | Append-only (historical) |
| Query pattern | Graph traversal | Time-series, aggregation |
| Primary key | Business identity | Run ID + timestamp |
| Integrity | Consistency | Tamper-evidence |
| Lifecycle | Current state | Retained history |

---

## Decision Drivers

1. **Auditability requirement** — Must prove what happened, when, by whom
2. **Reproducibility** — Must recreate past runs from manifest
3. **Compliance** — Audit logs must be tamper-evident
4. **Query efficiency** — Time-based queries are relational, not graph
5. **Separation of concerns** — Don't pollute knowledge model with operational noise
6. **Retention policies** — Audit data has different retention than current truth

---

## Considered Options

### Option 1 — Store everything in Neo4j

**Description:** Add audit nodes and relationships to the same graph database.

**Pros:**
- Single database to manage
- Can link audit to entities directly

**Cons:**
- Pollutes knowledge model with temporal data
- Graph queries become expensive with historical nodes
- Tamper-evidence harder to implement in graph
- Wrong tool for time-series queries

### Option 2 — Store everything in PostgreSQL

**Description:** Use relational database for both knowledge and audit.

**Pros:**
- Single database technology
- Strong audit patterns available
- Excellent time-series support

**Cons:**
- Loses graph benefits for knowledge model (see ADR-001)
- Multi-hop queries become expensive
- Invariants harder to express

### Option 3 — Dual-store: Neo4j + PostgreSQL ✅ **Chosen**

**Description:** Graph for knowledge, relational for audit. Reference between them via run_id.

**Pros:**
- Right tool for each job
- Clean separation of concerns
- Audit patterns well-established in PostgreSQL
- Knowledge model stays clean

**Cons:**
- Two databases to manage
- Must maintain consistency via run_id references
- Slightly more operational complexity

---

## Decision

We will use **PostgreSQL** as the audit/governance store with these principles:

### 1. Clear data ownership

| Store | Contains | Does Not Contain |
|-------|----------|------------------|
| **Neo4j** | Current structural truth | Run history, approvals |
| **PostgreSQL** | Run history, audit, governance | Business entities, relationships |

### 2. Run ID as the join key

Every run generates a unique `run_id` that appears in both stores:
- Neo4j nodes have `_run_id` property
- PostgreSQL tables have `run_id` foreign key

### 3. Append-only for audit tables

Audit tables (`checkpoint_approvals`, `overrides`, `error_log`) are:
- **Insert-only** — no updates or deletes
- **Tamper-evident** — hash chain linking records
- **Identity-bound** — reviewer identity from SSO/auth

---

## Decision Rationale

This approach is chosen because audit and knowledge have fundamentally different requirements:

> Audit data must prove what happened. Knowledge data must represent what is true.

These are different questions with different storage patterns.

---

## Consequences

### Positive Consequences

- Strong auditability and reproducibility
- Clean knowledge model without temporal noise
- Appropriate query patterns for each data type
- Easier compliance reporting (standard SQL)

### Negative Consequences

- Two databases to operate and backup
- Dual-store consistency requires discipline
- Cross-store queries need application logic

---

## References

- **Related ADRs:** ADR-001 (graph as SoR), ADR-003 (filesystem artifacts), ADR-008 (checkpoints), ADR-012 (audit integrity)
