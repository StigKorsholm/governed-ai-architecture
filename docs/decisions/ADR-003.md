# ADR-003: Artifacts in Filesystem with Run-Scoped Paths

> **Status:** ✅ Accepted  
> **Date:** 2025-12-22  
> **Triggered By:** ADR-001 (consequence: "We must store artifacts separately with run-scoped paths")  
> **Triggers:** —

---

## Summary

* **Decision:** Store generated artifacts (reports, diagrams, OpenAPI specs, SQL scripts, reconciliation packs) as immutable files under run-scoped paths: `/outputs/{run_id}/...`
* **Chosen approach:** Filesystem or object storage with run_id as the root folder, write-once semantics per run.
* **Why:** Artifacts are deliverables, not knowledge. They must be auditable, packageable, immutable per run, and easy to archive or deliver.
* **Scope:** This ADR covers artifact storage strategy. Specific file formats are defined by other ADRs (e.g., ADR-014 for OpenAPI).

---

## Context

The pipeline produces various artifacts as outputs:
- **Architecture reports** — Markdown, PDF
- **Diagrams** — Mermaid, C4, PlantUML
- **API specifications** — OpenAPI YAML
- **Migration scripts** — SQL
- **Reconciliation packs** — JSON validation data
- **Evidence appendices** — Markdown with queries

These artifacts are **outputs**, not **truth**. They are:
- Generated deterministically from the graph (ADR-015)
- Immutable once produced
- Tied to a specific run
- Subject to retention and access control
- Often delivered as packages to stakeholders

---

## Decision Drivers

1. **Auditability** — Must prove which artifacts came from which run
2. **Reproducibility** — Same run_id should produce same artifacts
3. **Deliverability** — Must package and deliver to stakeholders
4. **Immutability** — Artifacts must not change after generation
5. **Retention** — Must support retention policies

---

## Considered Options

### Option 1 — Store artifacts in PostgreSQL (BLOB)

**Cons:** Database size grows quickly; not designed for file serving

### Option 2 — Store artifacts in Neo4j

**Cons:** Completely wrong tool; graph performance destroyed

### Option 3 — Object storage (S3, MinIO)

**Pros:** Designed for large files; scalable

### Option 4 — Filesystem with run-scoped paths ✅ **Chosen**

**Pros:** Simple, well-understood, easy to package and deliver

---

## Decision

We will store artifacts in **filesystem with run-scoped paths**:

```
/outputs/
└── {run_id}/
    ├── manifest.json
    ├── reports/
    ├── diagrams/
    ├── api/
    ├── migration/
    └── validation/
```

### Principles

1. **Run-scoped** — All artifacts under `{run_id}/`
2. **Immutable** — Write-once per run
3. **Manifest links** — `manifest.json` links to audit DB
4. **Packageable** — Zip and deliver

---

## Consequences

### Positive Consequences

- Easy auditing — complete run package in one folder
- Simple retention policy — delete by run_id folder
- Reproducibility — manifest captures all inputs
- Packageable — zip and deliver

### Negative Consequences

- Storage growth (mitigated by retention policy)
- Requires access control implementation

---

## References

- **Related ADRs:** ADR-001 (separation of concerns), ADR-014 (OpenAPI format), ADR-015 (deterministic diagrams), ADR-016 (evidence appendix)
