# ADR-001: Graph as System of Record for Modernization Knowledge

> **Status:** ✅ Accepted  
> **Date:** 2025-12-22  
> **Triggered By:** ADR-000 (consequence: "We need a canonical representation of modernization knowledge")  
> **Triggers:** ADR-002, ADR-003, ADR-007, ADR-013, ADR-015

---

## Summary

* **Decision:** Use a graph database (Neo4j) as the primary system-of-record for all modernization knowledge — tables, capabilities, BIAN mappings, bounded contexts, microservices, migration waves, risks, etc.
* **Chosen approach:** Store entities as nodes, relationships as first-class edges, and invariants as queryable constraints.
* **Why:** Invariants are relationships, not rows. Traceability, constraint enforcement, and deterministic diagram generation require explicit structural representation that only a graph provides.
* **Scope:** This ADR covers why the knowledge model must be a graph. Technology selection (Neo4j) is a consequence, not the driver.

---

## Context

Every AI-assisted system must answer one fundamental question:

**Where does truth live?**

In demos, the answer is often: *"Whatever the model says."*

In production systems — especially regulated ones — that answer is unacceptable.

Truth must be:
- **Inspectable** — queryable, not inferred
- **Enforceable** — constraints must be executable
- **Stable across time** — not dependent on who remembers what

The modernization pipeline produces interconnected knowledge:
```
tables → capabilities → BIAN domains → bounded contexts → microservices → APIs → migration waves
```

Each arrow represents a relationship that must be:
- Explicitly stored
- Queryable
- Validated against invariants

This immediately disqualifies several common storage models.

---

## Decision Drivers

1. **Traceability requirement** — Must trace from legacy table to target microservice and back
2. **Invariant enforcement** — Must validate structural rules (e.g., "every table belongs to exactly one capability")
3. **Multi-hop queries** — Must answer questions like "what depends on this table transitively?"
4. **Deterministic outputs** — Diagrams and reports must be reproducible from the same data
5. **Lifecycle awareness** — What is "required" depends on which phase we're in
6. **Auditability** — Must explain why something is connected to something else

---

## Considered Options

### Option 1 — Relational database (PostgreSQL)

**Description:** Store entities in tables, relationships as foreign keys, use joins for traversal.

**Pros:**
- Mature, well-understood technology
- Strong transactional guarantees
- Excellent tooling

**Cons:**
- Relationships are implicit (reconstructed via joins)
- Multi-hop queries become expensive and complex
- Invariants must be encoded in application logic or triggers
- Schema changes are expensive when relationships evolve

### Option 2 — Document store (MongoDB)

**Description:** Store entities as JSON documents, embed or reference related entities.

**Pros:**
- Flexible schema
- Good for snapshots and generated content
- Easy to store LLM outputs verbatim

**Cons:**
- No native relationship enforcement
- Cannot prevent contradictions
- Global constraints require application code
- Preserves what was said, not what must be true

### Option 3 — Vector store (Pinecone, Weaviate)

**Description:** Store embeddings for semantic search and retrieval.

**Pros:**
- Excellent for similarity search
- Good for RAG patterns
- Scales well for retrieval

**Cons:**
- No concept of obligation or prohibition
- Cannot enforce structural rules
- "Close enough" is not acceptable for architectural truth
- Similarity ≠ correctness

### Option 4 — Property graph (Neo4j) ✅ **Chosen**

**Description:** Store entities as nodes, relationships as first-class edges with properties, use Cypher for traversal and constraint validation.

**Pros:**
- Relationships are explicit and queryable
- Multi-hop traversal is native and efficient
- Invariants can be expressed as Cypher queries
- Schema-flexible but structure-enforceable
- Deterministic diagram generation via queries

**Cons:**
- Team must learn graph thinking and Cypher
- Less mature tooling than relational
- Requires discipline in graph modeling
- Dual-store pattern needed for audit data

---

## Decision

We will use **Neo4j** as the primary system-of-record for modernization knowledge with these principles:

### 1. Relationships are first-class

Not implied. Not inferred. Not reconstructed at runtime.

**Explicit.**

```cypher
(:Table)-[:BELONGS_TO]->(:Capability)
(:Capability)-[:MAPS_TO]->(:BIANServiceDomain)
(:BoundedContext)-[:CONTAINS]->(:Capability)
(:Microservice)-[:IMPLEMENTS]->(:BehaviorQualifier)
```

### 2. Invariants are queryable

Every meaningful invariant is a graph pattern:

| Invariant | Cypher Pattern |
|-----------|----------------|
| Table must belong to one capability | `(t:Table)-[:BELONGS_TO]->(c:Capability)` — exactly one |
| Capability must map to BIAN | `(c:Capability)-[:MAPS_TO]->(sd:BIANServiceDomain)` — required |
| Migration wave respects dependencies | Path query — no cycles, correct order |
| Microservice must own something | `(ms:Microservice)-[:IMPLEMENTS]->()` — at least one |

### 3. Truth is queryable, not inferred

```cypher
// What capabilities does this table contribute to?
MATCH (t:Table {name: $tableName})-[:BELONGS_TO]->(c:Capability)
RETURN c.name

// What would break if we remove this service domain?
MATCH (sd:BIANServiceDomain {name: $sdName})<-[:MAPS_TO]-(c:Capability)
RETURN c.name AS affected_capabilities
```

### 4. The graph is authoritative for structure only

The graph stores:
- Structural truth
- Relationships
- Invariants

The graph does **not** store:
- Audit logs (→ PostgreSQL)
- Execution history (→ PostgreSQL)
- Generated artifacts (→ Filesystem)

---

## Decision Rationale

This approach is chosen because it solves the core failure mode of other storage models: **implicitness**.

In non-graph approaches, critical relationships exist only because:
- Someone encoded them in application logic
- Someone remembers how things "usually" fit together

They are not enforced by the system itself.

Once that happens:
- Validation becomes ad-hoc
- Reasoning becomes narrative
- Drift becomes inevitable

A graph makes relationships explicit, which means:
- **Validators can query the graph** — not parse application code
- **Diagrams can be generated from queries** — not from LLM narrative
- **Confidence can be grounded in structure** — not in model self-reporting

---

## Consequences

### Architectural Implications

| Consequence | Triggers ADR |
|-------------|--------------|
| We must separate audit/governance data from knowledge model | ADR-002 |
| We must store artifacts separately with run-scoped paths | ADR-003 |
| We must define and enforce graph invariants as contracts | ADR-007 |
| We need a canonical reference model to map to | ADR-013 |
| Diagrams must be generated from graph queries, not narrative | ADR-015 |

### Positive Consequences

- Enables end-to-end traceability across the modernization chain
- Invariant checks become Cypher queries, not scattered application code
- Deterministic diagram generation (same query → same diagram)
- Clear separation of concerns (graph = knowledge, other stores = audit/artifacts)
- Multi-hop impact analysis becomes trivial

### Negative Consequences

- Requires graph modeling discipline from the team
- Team must learn Cypher and graph thinking
- Dual-store consistency requirements (graph ↔ relational for audit)
- Some queries that are simple in SQL become different in Cypher

### What Breaks Without This Decision

If the knowledge model is not a graph:

| Failure Mode | Consequence |
|--------------|-------------|
| Validators become ad-hoc scripts | No authoritative model to validate against |
| Diagrams drift from reality | Generated from narrative, not structure |
| Confidence loses meaning | No deterministic signal source |
| Human review becomes archaeology | No queryable context |
| Learning corrupts past | No stable baseline to compare against |

The system still runs. But it slowly becomes ungovernable.

---

## Notes / Out of Scope

- Specific Neo4j version, deployment topology, and backup strategy are implementation details.
- The graph stores current truth, not history. Historical snapshots are captured via run manifests and audit logs in PostgreSQL.
- "Graph as system of record" does not mean "graph for everything" — see ADR-002 and ADR-003 for complementary stores.

---

## References

- **LinkedIn Article:** [Why the Knowledge Model Must Be a Graph (and What Breaks When It Isn't)](https://www.linkedin.com/pulse/why-knowledge-model-must-graph-what-breaks-when-isnt-korsholm-6zzte) (2026-01-04)
- **Related ADRs:** ADR-000 (root), ADR-002 (audit store), ADR-007 (invariants), ADR-015 (diagrams)
